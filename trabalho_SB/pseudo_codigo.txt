#define TAMANHO_CABECALHO 24

struct bloco {
    int tamanho_bloco;
    int * prox;
    int * ant;
}

struct bloco * cabeca_lista_livre = NULL;

int * memory_alloc (unsigned long tamanho_bloco) {
    unsigned long tamanho_total_necessario = tamanho_solicitado + TAMANHO_CABECALHO;

    struct bloco * bloco_atual = cabeca_lista_livre;
    struct bloco * bloco_worst_fit = NULL;
    unsigned long tamanho_worst_fit = 0;

    while (bloco_atual != NULL) {
        if (bloco_atual->tamanho_bloco >= tamanho_total_necessario) {
            // Pega o maior
            if (bloco_atual->tamanho_bloco > tamanho_worst_fit) {
                bloco_worst_fit = bloco_atual;
                tamanho_worst_fit = bloco_atual->tamanho_bloco;
            }
        }
        // Pula para o PRÓXIMO bloco LIVRE 
        bloco_atual = bloco_atual->prox; 
    }

    if (bloco_worst_fit != NULL) {
        
        unsigned long tamanho_restante = bloco_worst_fit->tamanho_bloco - tamanho_total_necessario;

        // "bytes extras suficientes" = cabeçalho (24) + 1 byte de dado
        if (tamanho_restante >= (TAMANHO_CABECALHO + 1)) {
            // Dividir!
            // 1. Criar o novo bloco livre no final do bloco que vamos usar
            struct bloco * novo_bloco_livre_dividido = (void *) bloco_worst_fit + tamanho_total_necessario;
            
            // 2. Configurar o novo bloco dividido
            novo_bloco_livre_dividido->tamanho_bloco = tamanho_restante;
            
            // 3. Adicionar o novo bloco dividido na lista de livres
            adicionar_na_lista_livre(novo_bloco_livre_dividido);
            
            // 4. Encolher o bloco que vamos retornar
            bloco_worst_fit->tamanho_bloco = tamanho_total_necessario;

        } 
        // else: Não dividir, o usuário leva o bloco inteiro (fragmentação interna)

        // B. Remover o bloco da lista de livres
        // (Esta é outra função auxiliar que você terá que criar)
        remover_da_lista_livre(bloco_worst_fit);

        // C. Retornar o ponteiro para a ÁREA DE DADOS do usuário
        return (void*)bloco_worst_fit + TAMANHO_CABECALHO;
    }
    
    // --- CASO 2: Não, não encontramos bloco livre (precisamos de mais heap) ---
    else {
        // 1. Chamar sbrk() para alocar EXATAMENTE o que precisamos
        struct bloco * novo_bloco = sbrk(tamanho_total_necessario);

        if (novo_bloco == (void*)-1) {
            return NULL; // Falha (Out of Memory)
        }

        // 2. Configurar o cabeçalho do novo bloco
        novo_bloco->tamanho_bloco = tamanho_total_necessario;
        // prox e ant são irrelevantes, pois o bloco já nasce ocupado
        // e não está na lista de livres.

        // 3. Retornar o ponteiro para a ÁREA DE DADOS do usuário
        return (void*)novo_bloco + TAMANHO_CABECALHO;
    }
}